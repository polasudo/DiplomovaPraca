AWSTemplateFormatVersion: '2010-09-09'
Description: >-
  (SHOWCASE ONLY - NO FUNCTIONAL LOGIC) CloudFormation template demonstrating a
  scaled serverless backend structure based on the "Maturation" text. Includes API Gateway,
  Lambda (placeholders with specific roles), DynamoDB, Cognito, Step Functions, RDS (PostgreSQL),
  ElastiCache (Redis), and basic VPC. Lambdas are non-functional placeholders.

Parameters:
  ProjectName:
    Type: String
    Description: A prefix for resource names to ensure uniqueness and grouping.
  DbPasswordSecretName:
    Type: String
    Description: Name for the RDS database master password secret in Secrets Manager.
  PowertoolsLayerArn:
    Type: String
    Description: ARN of the AWS Lambda Powertools Layer for Python
    Default: "arn:aws:lambda:eu-central-1:017000801446:layer:AWSLambdaPowertoolsPythonV3-python39-x86_64:14"

Resources:
  ### VPC & Networking ###
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Project
          Value: myProject

  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnetA:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs ""]
      MapPublicIpOnLaunch: true

  PublicSubnetB:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [1, !GetAZs ""]
      MapPublicIpOnLaunch: true
  
  RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC


  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  SubnetARouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetA
      RouteTableId: !Ref RouteTable

  SubnetBRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetB
      RouteTableId: !Ref RouteTable

  ### Security Groups ###
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${ProjectName}-LambdaSG"
      GroupDescription: Security group for Lambda functions running in VPC
      VpcId: !Ref VPC
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0


  ElastiCacheSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${ProjectName}-ElastiCacheSG"
      GroupDescription: Security group for ElastiCache Redis Cluster
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 6379
          ToPort: 6379
          SourceSecurityGroupId: !Ref LambdaSecurityGroup


  RDSSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${ProjectName}-RDSSG"
      GroupDescription: Security group for RDS PostgreSQL Instance
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref LambdaSecurityGroup


  ### DynamoDB ###
  CustomersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${ProjectName}-Customers"
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST


  OrdersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${ProjectName}-Orders"
      AttributeDefinitions:
        - AttributeName: orderId
          AttributeType: S
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: orderId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: UserOrdersIndex
          KeySchema:
            - AttributeName: userId
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      BillingMode: PAY_PER_REQUEST


  FeedbackTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${ProjectName}-Feedback"
      AttributeDefinitions:
        - AttributeName: feedbackId
          AttributeType: S
      KeySchema:
        - AttributeName: feedbackId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST


  ### Cognito ###
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "${ProjectName}-UserPool"
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: true
          Required: true
      Policies:
        PasswordPolicy:
          MinimumLength: 8
      AutoVerifiedAttributes:
        - email
      UsernameAttributes:
        - email

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub "${ProjectName}-WebAppClient"
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_ADMIN_USER_PASSWORD_AUTH # Add this line
        - ALLOW_USER_SRP_AUTH
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
      PreventUserExistenceErrors: ENABLED

  ### ElastiCache ###
  ElastiCacheSubnetGroup:
    Type: AWS::ElastiCache::SubnetGroup
    Properties:
      Description: Subnet group for ElastiCache cluster
      SubnetIds:
        - !Ref PublicSubnetA
        - !Ref PublicSubnetB


  RedisCacheCluster:
    Type: AWS::ElastiCache::CacheCluster
    Properties:
      CacheNodeType: cache.t3.micro
      Engine: redis
      NumCacheNodes: 1
      CacheSubnetGroupName: !Ref ElastiCacheSubnetGroup
      VpcSecurityGroupIds:
        - !GetAtt ElastiCacheSecurityGroup.GroupId
      ClusterName: !Sub "${ProjectName}-redis-cluster"


  ### RDS & Secrets ###
  RDSDbSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for RDS instance
      SubnetIds:
        - !Ref PublicSubnetA
        - !Ref PublicSubnetB


  DBPasswordSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Ref DbPasswordSecretName
      Description: !Sub "Password for ${ProjectName} RDS instance"
      GenerateSecretString:
        SecretStringTemplate: '{"username":"dbadmin"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludePunctuation: true


  AnalyticsDBInstance:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Snapshot
    UpdateReplacePolicy: Snapshot
    Properties:
      DBInstanceIdentifier: !Sub "${ProjectName}-analytics-db"
      DBName: !Sub "${ProjectName}AnalyticsDB"
      Engine: postgres
      EngineVersion: "15"
      DBInstanceClass: db.t3.micro
      AllocatedStorage: "20"
      MasterUsername: !Join ["", ["{{resolve:secretsmanager:", !Ref DBPasswordSecret, ":SecretString:username}}"]]
      MasterUserPassword: !Join ["", ["{{resolve:secretsmanager:", !Ref DBPasswordSecret, ":SecretString:password}}"]]
      DBSubnetGroupName: !Ref RDSDbSubnetGroup
      VPCSecurityGroups:
        - !GetAtt RDSSecurityGroup.GroupId
      PubliclyAccessible: false
      StorageType: gp3
      BackupRetentionPeriod: 7
      DeleteAutomatedBackups: true
      DeletionProtection: false


  ### IAM Roles ###
  AuthLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-AuthLambdaRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${ProjectName}-AuthLambdaBasePolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: "*"
        - PolicyName: !Sub "${ProjectName}-AuthLambdaCognitoPolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cognito-idp:AdminGetUser
                  - cognito-idp:AdminInitiateAuth
                  - cognito-idp:AdminRespondToAuthChallenge
                  - cognito-idp:SignUp
                  - cognito-idp:ConfirmSignUp # This is usually for user-initiated confirmation
                  - cognito-idp:AdminConfirmSignUp
                Resource: !GetAtt UserPool.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt CustomersTable.Arn

  OrderLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-OrderLambdaRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${ProjectName}-OrderLambdaBasePolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: "*"
        - PolicyName: !Sub "${ProjectName}-OrderLambdaDynamoDBPolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt OrdersTable.Arn
                  - !Sub "${OrdersTable.Arn}/index/UserOrdersIndex"

  FeedbackLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-FeedbackLambdaRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${ProjectName}-FeedbackLambdaBasePolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: "*"
        - PolicyName: !Sub "${ProjectName}-FeedbackLambdaDynamoDBPolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt FeedbackTable.Arn

  AnalyticsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-AnalyticsLambdaRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${ProjectName}-AnalyticsLambdaBasePolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: "*"
        - PolicyName: !Sub "${ProjectName}-AnalyticsLambdaDynamoDBPolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:GetItem
                Resource:
                  - !GetAtt CustomersTable.Arn
                  - !GetAtt OrdersTable.Arn
                  - !Sub "${OrdersTable.Arn}/index/*"
        - PolicyName: !Sub "${ProjectName}-AnalyticsLambdaRDSPolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: secretsmanager:GetSecretValue
                Resource: !Ref DBPasswordSecret

  PaymentStepLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-PaymentStepLambdaRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${ProjectName}-PaymentStepLambdaBasePolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                  - ec2:AssignPrivateIpAddresses
                  - ec2:UnassignPrivateIpAddresses
                Resource: "*"

  StateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ProjectName}-StateMachineRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub "states.${AWS::Region}.amazonaws.com"
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "${ProjectName}-StateMachineLambdaInvokePolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource:
                  - !GetAtt PaymentStepLambdaFunction.Arn
        - PolicyName: !Sub "${ProjectName}-StateMachineXRayPolicy"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: "*"

  ApiGatewayLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs

  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayLogsRole.Arn

  ### Lambda Functions (placeholders) ###
  RegisterUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-RegisterUser"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt AuthLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from decimal import Decimal
          from botocore.exceptions import ClientError
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent
          from aws_lambda_powertools.utilities.typing import LambdaContext

          # Powertools initialization
          logger = Logger(service="register-user")
          tracer = Tracer(service="register-user")
          metrics = Metrics(namespace="MyApp", service="register-user")

          cognito = boto3.client("cognito-idp")
          dynamodb = boto3.resource("dynamodb")

          USER_POOL_ID = os.environ.get("COGNITO_USER_POOL_ID")
          CLIENT_ID = os.environ.get("COGNITO_CLIENT_ID")
          CUSTOMERS_TABLE_NAME = os.environ.get("CUSTOMERS_TABLE_NAME")

          table = None
          if CUSTOMERS_TABLE_NAME:
              table = dynamodb.Table(CUSTOMERS_TABLE_NAME)

          def _json_response(status_code, body):
              return {
                  "statusCode": status_code,
                  "headers": {
                      "Content-Type": "application/json",
                      "Access-Control-Allow-Origin": "*"
                  },
                  "body": json.dumps(body),
              }

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              event_obj = APIGatewayProxyEvent(event)
              logger.info("RegisterUser lambda triggered")

              # Parse and validate request
              try:
                  data = json.loads(event_obj.body or "{}")
              except Exception:
                  return _json_response(400, {"error": "Invalid JSON in request body"})

              required = ["email", "password", "firstName", "lastName"]
              missing = [f for f in required if not data.get(f)]
              if missing:
                  return _json_response(400, {"error": f"Missing required fields: {', '.join(missing)}"})

              email = data["email"]
              password = data["password"]
              first_name = data["firstName"]
              last_name = data["lastName"]
              phone = data.get("phoneNumber")

              # Call Cognito sign_up
              try:
                  cognito_kwargs = {
                      "ClientId": CLIENT_ID,
                      "Username": email,
                      "Password": password,
                      "UserAttributes": [
                          {"Name": "email", "Value": email},
                          {"Name": "name", "Value": first_name},
                          {"Name": "family_name", "Value": last_name},
                      ]
                  }
                  if phone:
                      cognito_kwargs["UserAttributes"].append({"Name": "phone_number", "Value": phone})
                  logger.info("Calling Cognito sign_up", extra={"username": email})
                  resp = cognito.sign_up(**cognito_kwargs)
                  user_sub = resp["UserSub"]
                  logger.info("Cognito sign_up success", extra={"userSub": user_sub})

                  try:
                    logger.info(f"Attempting to auto-confirm user {email}")
                    cognito.admin_confirm_sign_up(UserPoolId=USER_POOL_ID, Username=email)
                    logger.info(f"Auto-confirmation successful for user {email}")
                  except Exception as e:
                    logger.error(f"Failed to auto-confirm user {email} via admin_confirm_sign_up.", 
                         extra={"error": str(e_confirm), "username": email})
                  metrics.add_metric(name="SuccessfulRegistration", unit="Count", value=1)

              except cognito.exceptions.UsernameExistsException:
                  logger.warning("User already exists", extra={"username": email})
                  metrics.add_metric(name="RegistrationConflict", unit="Count", value=1)
                  return _json_response(409, {"error": "User already exists"})

              except ClientError as e:
                  logger.exception("Cognito ClientError during registration")
                  metrics.add_metric(name="RegistrationFailed", unit="Count", value=1)
                  return _json_response(500, {"error": e.response["Error"]["Message"]})

              except Exception as e:
                  logger.exception("Unknown error during Cognito registration")
                  metrics.add_metric(name="RegistrationFailed", unit="Count", value=1)
                  return _json_response(500, {"error": "Internal server error"})

              # Store user to DynamoDB (optional, if table is set)
              if table:
                  import time
                  try:
                      item = {
                          "userId": user_sub,
                          "email": email,
                          "firstName": first_name,
                          "lastName": last_name,
                          "createdAt": Decimal(int(time.time())),
                          "updatedAt": Decimal(int(time.time()))
                      }
                      if phone:
                          item["phoneNumber"] = phone
                      table.put_item(Item=item)
                      logger.info("User record inserted in DynamoDB", extra={"userId": user_sub})
                  except Exception as e:
                      logger.exception("Failed to insert user in DynamoDB")
                      # Still return 201 because Cognito registration succeeded
                      return _json_response(201, {
                          "message": "User registered successfully (but not stored in Customers table)",
                          "userSub": user_sub,
                          "warning": "DynamoDB operation failed"
                      })

              # Return success response
              return _json_response(201, {
                  "message": "User registered successfully",
                  "userSub": user_sub
              })
      Environment:
        Variables:
          COGNITO_USER_POOL_ID: !Ref UserPool
          COGNITO_CLIENT_ID:    !Ref UserPoolClient
          CUSTOMERS_TABLE_NAME: !Ref CustomersTable
      Timeout: 15
      MemorySize: 128
      TracingConfig:
        Mode: Active

  LoginUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-LoginUser"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt AuthLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from botocore.exceptions import ClientError
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent
          from aws_lambda_powertools.utilities.typing import LambdaContext

          # Powertools initialization
          logger = Logger(service="login-user")
          tracer = Tracer(service="login-user")
          metrics = Metrics(namespace="MyApp", service="login-user")

          cognito = boto3.client("cognito-idp")

          USER_POOL_ID = os.environ.get("COGNITO_USER_POOL_ID")
          CLIENT_ID = os.environ.get("COGNITO_CLIENT_ID")

          def _json_response(status_code, body):
              return {
                  "statusCode": status_code,
                  "headers": {
                      "Content-Type": "application/json",
                      "Access-Control-Allow-Origin": "*"
                  },
                  "body": json.dumps(body),
              }

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              event_obj = APIGatewayProxyEvent(event)
              logger.info("LoginUser lambda triggered")

              # Parse and validate request
              try:
                  data = json.loads(event_obj.body or "{}")
              except Exception:
                  return _json_response(400, {"error": "Invalid JSON in request body"})

              email = data.get("email")
              password = data.get("password")
              if not email or not password:
                  return _json_response(400, {"error": "Missing required fields: email, password"})

              try:
                  # Use AdminInitiateAuth for backend
                  resp = cognito.admin_initiate_auth(
                      UserPoolId=USER_POOL_ID,
                      ClientId=CLIENT_ID,
                      AuthFlow="ADMIN_USER_PASSWORD_AUTH",
                      AuthParameters={
                          "USERNAME": email,
                          "PASSWORD": password
                      }
                  )
                  logger.info("Cognito admin_initiate_auth success", extra={"username": email})
                  metrics.add_metric(name="LoginSuccess", unit="Count", value=1)

                  tokens = resp.get("AuthenticationResult", {})
                  return _json_response(200, {
                      "message": "Login successful",
                      "idToken": tokens.get("IdToken"),
                      "accessToken": tokens.get("AccessToken"),
                      "refreshToken": tokens.get("RefreshToken"),
                      "expiresIn": tokens.get("ExpiresIn")
                  })

              except cognito.exceptions.NotAuthorizedException:
                  logger.warning("Invalid login attempt", extra={"username": email})
                  metrics.add_metric(name="LoginFailed", unit="Count", value=1)
                  return _json_response(401, {"error": "Invalid username or password"})

              except cognito.exceptions.UserNotFoundException:
                  logger.warning("User not found", extra={"username": email})
                  metrics.add_metric(name="LoginFailed", unit="Count", value=1)
                  return _json_response(401, {"error": "Invalid username or password"})

              except cognito.exceptions.UserNotConfirmedException:
                  logger.info("User not confirmed", extra={"username": email})
                  return _json_response(403, {"error": "User account not confirmed"})

              except ClientError as e:
                  logger.exception("Cognito ClientError during login")
                  metrics.add_metric(name="LoginError", unit="Count", value=1)
                  return _json_response(500, {"error": e.response["Error"]["Message"]})

              except Exception as e:
                  logger.exception("Unknown error during login")
                  metrics.add_metric(name="LoginError", unit="Count", value=1)
                  return _json_response(500, {"error": "Internal server error"})

      Environment:
        Variables:
          COGNITO_USER_POOL_ID: !Ref UserPool
          COGNITO_CLIENT_ID:    !Ref UserPoolClient
      Timeout: 10
      MemorySize: 128
      TracingConfig:
        Mode: Active



  CreateOrderFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-CreateOrder"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt OrderLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import uuid
          import time
          import boto3
          from decimal import Decimal
          from botocore.exceptions import ClientError
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.event_handler import APIGatewayRestResolver
          from aws_lambda_powertools.utilities.typing import LambdaContext
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent

          # Initialize PowerTools
          logger = Logger(service="create-order")
          tracer = Tracer(service="create-order")
          metrics = Metrics(namespace="MyApp", service="create-order")

          # Initialize DynamoDB client
          dynamodb = boto3.resource('dynamodb')

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              # Create API Gateway event object for easier parsing
              event_obj = APIGatewayProxyEvent(event)
              function_name = context.function_name
              
              # Log structured information
              logger.info("Function invoked", extra={
                  "function_name": function_name,
                  "request_id": context.aws_request_id
              })
              
              # Add custom annotation for X-Ray
              tracer.put_annotation(key="function_name", value=function_name)
              
              # Add business metrics
              metrics.add_metric(name="OrderCreationAttempt", unit="Count", value=1)
              
              # Get the DynamoDB table name from environment variables
              table_name = os.environ.get('TABLE_NAME')
              tracer.put_metadata(key="table_name", value=table_name)
              
              # Get the table resource
              table = dynamodb.Table(table_name)
              
              try:
                  # Parse the request body
                  if event_obj.body:
                      request_data = json.loads(event_obj.body)
                  else:
                      return {
                          "statusCode": 400,
                          "headers": {"Content-Type": "application/json"},
                          "body": json.dumps({"error": "Missing request body"})
                      }
                  
                  # Validate required fields
                  required_fields = ['userId', 'items', 'shippingAddress']
                  missing_fields = [field for field in required_fields if field not in request_data]
                  
                  if missing_fields:
                      return {
                          "statusCode": 400,
                          "headers": {"Content-Type": "application/json"},
                          "body": json.dumps({"error": f"Missing required fields: {', '.join(missing_fields)}"})
                      }
                  
                  # Validate items array
                  if not isinstance(request_data['items'], list) or len(request_data['items']) == 0:
                      return {
                          "statusCode": 400,
                          "headers": {"Content-Type": "application/json"},
                          "body": json.dumps({"error": "Items must be a non-empty array"})
                      }
                  
                  # Generate a unique order ID
                  order_id = str(uuid.uuid4())
                  timestamp = int(time.time())
                      
                  # Calculate order total and convert numeric values to Decimal
                  order_total = Decimal(sum(Decimal(str(item.get('price', 0))) * Decimal(str(item.get('quantity', 1))) for item in request_data['items']))
                      
                  # Convert all numeric values in items to Decimal
                  decimal_items = []
                  for item in request_data['items']:
                      decimal_item = {}
                      for key, value in item.items():
                          if isinstance(value, (int, float)):
                              decimal_item[key] = Decimal(str(value))
                          else:
                              decimal_item[key] = value
                      decimal_items.append(decimal_item)
                      
                  # Prepare order data for DynamoDB
                  order_item = {
                      'orderId': order_id,
                      'userId': request_data['userId'],
                      'items': decimal_items,
                      'shippingAddress': request_data['shippingAddress'],
                      'orderTotal': order_total,
                      'status': 'PENDING',
                      'createdAt': Decimal(timestamp),
                      'updatedAt': Decimal(timestamp)
                  }
                      
                  # Add optional fields if present
                  if 'paymentMethod' in request_data:
                      order_item['paymentMethod'] = request_data['paymentMethod']
                      
                  if 'notes' in request_data:
                      order_item['notes'] = request_data['notes']
                      
                  # Write to DynamoDB
                  table.put_item(Item=order_item)
                      
                  # Log success and add metrics
                  logger.info("Order created successfully", extra={
                      "orderId": order_id,
                      "userId": request_data['userId'],
                      "orderTotal": order_total
                  })
                  metrics.add_metric(name="SuccessfulOrderCreation", unit="Count", value=1)
                  metrics.add_metric(name="OrderValue", unit="None", value=order_total)
                      
                  # Prepare success response
                  response_body = {
                      "message": "Order created successfully",
                      "orderId": order_id,
                      "status": "PENDING",
                      "orderTotal": float(order_total)  # Convert back to float for JSON response
                  }
              
              except ClientError as e:
                  # Handle DynamoDB errors
                  error_code = e.response['Error']['Code']
                  error_message = e.response['Error']['Message']
                  
                  logger.error("DynamoDB error", extra={
                      "error_code": error_code,
                      "error_message": error_message
                  })
                  
                  metrics.add_metric(name="DatabaseError", unit="Count", value=1)
                  
                  return {
                      "statusCode": 500,
                      "headers": {"Content-Type": "application/json"},
                      "body": json.dumps({"error": "Database operation failed"})
                  }
              
              except Exception as e:
                  # Handle general errors
                  logger.exception("Error processing order creation")
                  metrics.add_metric(name="ProcessingError", unit="Count", value=1)
                  
                  return {
                      "statusCode": 500,
                      "headers": {"Content-Type": "application/json"},
                      "body": json.dumps({"error": "Internal server error"})
                  }
              
              return {
                  "statusCode": 201,  # Created
                  "headers": {
                      "Content-Type": "application/json"
                  },
                  "body": json.dumps(response_body)
              }
      Environment:
        Variables:
          TABLE_NAME:     !Ref OrdersTable
          REDIS_ENDPOINT: !GetAtt RedisCacheCluster.RedisEndpoint.Address
          REDIS_PORT:     !GetAtt RedisCacheCluster.RedisEndpoint.Port
      Timeout: 15
      MemorySize: 128
      TracingConfig:
        Mode: Active



  GetOrdersFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-GetOrders"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt OrderLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from decimal import Decimal
          from botocore.exceptions import ClientError
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.event_handler import APIGatewayRestResolver
          from aws_lambda_powertools.utilities.typing import LambdaContext
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent
          
          # Helper class to convert Decimal to float for JSON serialization
          class DecimalEncoder(json.JSONEncoder):
              def default(self, o):
                  if isinstance(o, Decimal):
                      return float(o)
                  return super(DecimalEncoder, self).default(o)

          # Initialize PowerTools
          logger = Logger(service="get-orders")
          tracer = Tracer(service="get-orders")
          metrics = Metrics(namespace="MyApp", service="get-orders")

          # Initialize DynamoDB client
          dynamodb = boto3.resource('dynamodb')

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              # Create API Gateway event object for easier parsing
              event_obj = APIGatewayProxyEvent(event)
              function_name = context.function_name
              
              # Log structured information
              logger.info("Function invoked", extra={
                  "function_name": function_name,
                  "request_id": context.aws_request_id
              })
              
              # Add custom annotation for X-Ray
              tracer.put_annotation(key="function_name", value=function_name)
              
              # Add business metrics
              metrics.add_metric(name="OrdersListRequest", unit="Count", value=1)
              
              # Get the DynamoDB table name and index from environment variables
              table_name = os.environ.get('TABLE_NAME')
              index_name = os.environ.get('INDEX_NAME')
              tracer.put_metadata(key="table_name", value=table_name)
              tracer.put_metadata(key="index_name", value=index_name)
              
              # Get the table resource
              table = dynamodb.Table(table_name)
              
              try:
                  # Get userId from path parameters
                  path_parameters = event_obj.path_parameters or {}
                  user_id = path_parameters.get('userId')
                  
                  # If userId is not in path parameters, try to get it from query parameters
                  if not user_id and event_obj.query_string_parameters:
                      user_id = event_obj.query_string_parameters.get('userId')
                  
                  # Validate userId is provided
                  if not user_id:
                      return {
                          "statusCode": 400,
                          "headers": {"Content-Type": "application/json"},
                          "body": json.dumps({"error": "Missing required parameter: userId"})
                      }
                  
                  # Get pagination parameters if provided
                  query_params = event_obj.query_string_parameters or {}
                  limit = int(query_params.get('limit', 20))  # Default to 20 items
                  last_evaluated_key = None
                  
                  # If nextToken is provided, decode it for pagination
                  if 'nextToken' in query_params:
                      import base64
                      try:
                          last_evaluated_key_json = base64.b64decode(query_params['nextToken']).decode('utf-8')
                          last_evaluated_key = json.loads(last_evaluated_key_json)
                      except Exception as e:
                          logger.warning("Invalid nextToken", extra={"error": str(e)})
                  
                  # Create a subsegment for database operations
                  # Query parameters for DynamoDB
                  query_params = {
                      'IndexName': index_name,
                      'KeyConditionExpression': 'userId = :userId',
                      'ExpressionAttributeValues': {
                          ':userId': user_id
                      },
                      'Limit': limit,
                      'ScanIndexForward': False  # Sort by most recent first
                  }
                  
                  # Add ExclusiveStartKey for pagination if we have a last evaluated key
                  if last_evaluated_key:
                      query_params['ExclusiveStartKey'] = last_evaluated_key
                  
                  # Query DynamoDB
                  response = table.query(**query_params)
                  
                  # Prepare items for response
                  items = response.get('Items', [])
                  
                  # Prepare pagination token if there are more results
                  next_token = None
                  if 'LastEvaluatedKey' in response:
                      import base64
                      last_key_json = json.dumps(response['LastEvaluatedKey'])
                      next_token = base64.b64encode(last_key_json.encode('utf-8')).decode('utf-8')
                  
                  # Log success and add metrics
                  logger.info("Orders retrieved successfully", extra={
                      "userId": user_id,
                      "count": len(items)
                  })
                  metrics.add_metric(name="OrdersRetrieved", unit="Count", value=len(items))
                  
                  # Prepare success response
                  response_body = {
                      "orders": items,
                      "count": len(items)
                  }
                  
                  # Add pagination token if available
                  if next_token:
                      response_body["nextToken"] = next_token
              
              except ClientError as e:
                  # Handle DynamoDB errors
                  error_code = e.response['Error']['Code']
                  error_message = e.response['Error']['Message']
                  
                  logger.error("DynamoDB error", extra={
                      "error_code": error_code,
                      "error_message": error_message
                  })
                  
                  metrics.add_metric(name="DatabaseError", unit="Count", value=1)
                  
                  return {
                      "statusCode": 500,
                      "headers": {"Content-Type": "application/json"},
                      "body": json.dumps({"error": "Database operation failed"})
                  }
              
              except Exception as e:
                  # Handle general errors
                  logger.exception("Error retrieving orders")
                  metrics.add_metric(name="ProcessingError", unit="Count", value=1)
                  
                  return {
                      "statusCode": 500,
                      "headers": {"Content-Type": "application/json"},
                      "body": json.dumps({"error": "Internal server error"})
                  }
              
              return {
                  "statusCode": 200,
                  "headers": {
                      "Content-Type": "application/json"
                  },
                  "body": json.dumps(response_body, cls=DecimalEncoder)
              }
      Environment:
        Variables:
          TABLE_NAME:     !Ref OrdersTable
          INDEX_NAME:     UserOrdersIndex
          REDIS_ENDPOINT: !GetAtt RedisCacheCluster.RedisEndpoint.Address
          REDIS_PORT:     !GetAtt RedisCacheCluster.RedisEndpoint.Port
      Timeout: 15
      MemorySize: 128
      TracingConfig:
        Mode: Active



  GetOrderDetailsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-GetOrderDetails"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt OrderLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from decimal import Decimal
          from botocore.exceptions import ClientError
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.event_handler import APIGatewayRestResolver
          from aws_lambda_powertools.utilities.typing import LambdaContext
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent
          
          # Helper class to convert Decimal to float for JSON serialization
          class DecimalEncoder(json.JSONEncoder):
              def default(self, o):
                  if isinstance(o, Decimal):
                      return float(o)
                  return super(DecimalEncoder, self).default(o)

          # Initialize PowerTools
          logger = Logger(service="get-order-details")
          tracer = Tracer(service="get-order-details")
          metrics = Metrics(namespace="MyApp", service="get-order-details")

          # Initialize DynamoDB client
          dynamodb = boto3.resource('dynamodb')

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              # Create API Gateway event object for easier parsing
              event_obj = APIGatewayProxyEvent(event)
              function_name = context.function_name
              
              # Log structured information
              logger.info("Function invoked", extra={
                  "function_name": function_name,
                  "request_id": context.aws_request_id
              })
              
              # Add custom annotation for X-Ray
              tracer.put_annotation(key="function_name", value=function_name)
              
              # Add business metrics
              metrics.add_metric(name="OrderDetailsRequest", unit="Count", value=1)
              
              # Get the DynamoDB table name from environment variables
              table_name = os.environ.get('TABLE_NAME')
              tracer.put_metadata(key="table_name", value=table_name)
              
              # Get the table resource
              table = dynamodb.Table(table_name)
              
              try:
                  # Get orderId from path parameters
                  path_parameters = event_obj.path_parameters or {}
                  order_id = path_parameters.get('orderId')
                  
                  # If orderId is not in path parameters, try to get it from query parameters
                  if not order_id and event_obj.query_string_parameters:
                      order_id = event_obj.query_string_parameters.get('orderId')
                  
                  # Validate orderId is provided
                  if not order_id:
                      return {
                          "statusCode": 400,
                          "headers": {"Content-Type": "application/json"},
                          "body": json.dumps({"error": "Missing required parameter: orderId"})
                      }
                  
                  # Get item from DynamoDB
                  response = table.get_item(
                      Key={
                          'orderId': order_id
                      }
                  )
                      
                  # Check if the item exists
                  if 'Item' not in response:
                      logger.warning("Order not found", extra={"orderId": order_id})
                      return {
                          "statusCode": 404,
                          "headers": {"Content-Type": "application/json"},
                          "body": json.dumps({"error": "Order not found"})
                      }
                      
                  # Get the order item
                  order = response['Item']
                      
                  # Check if the user has permission to access this order
                  # This would typically involve checking the authenticated user's ID
                  # against the userId in the order, but for this example we'll skip that
                      
                  # Log success and add metrics
                  logger.info("Order details retrieved successfully", extra={
                      "orderId": order_id,
                      "userId": order.get('userId')
                  })
                  metrics.add_metric(name="OrderDetailsRetrieved", unit="Count", value=1)
                      
                  # Prepare success response
                  response_body = {
                      "order": order
                  }
              
              except ClientError as e:
                  # Handle DynamoDB errors
                  error_code = e.response['Error']['Code']
                  error_message = e.response['Error']['Message']
                  
                  logger.error("DynamoDB error", extra={
                      "error_code": error_code,
                      "error_message": error_message
                  })
                  
                  metrics.add_metric(name="DatabaseError", unit="Count", value=1)
                  
                  return {
                      "statusCode": 500,
                      "headers": {"Content-Type": "application/json"},
                      "body": json.dumps({"error": "Database operation failed"})
                  }
              
              except Exception as e:
                  # Handle general errors
                  logger.exception("Error retrieving order details")
                  metrics.add_metric(name="ProcessingError", unit="Count", value=1)
                  
                  return {
                      "statusCode": 500,
                      "headers": {"Content-Type": "application/json"},
                      "body": json.dumps({"error": "Internal server error"})
                  }
              
              return {
                  "statusCode": 200,
                  "headers": {
                      "Content-Type": "application/json"
                  },
                  "body": json.dumps(response_body, cls=DecimalEncoder)
              }
      Environment:
        Variables:
          TABLE_NAME:     !Ref OrdersTable
          REDIS_ENDPOINT: !GetAtt RedisCacheCluster.RedisEndpoint.Address
          REDIS_PORT:     !GetAtt RedisCacheCluster.RedisEndpoint.Port
      Timeout: 15
      MemorySize: 128
      TracingConfig:
        Mode: Active



  SubmitFeedbackFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-SubmitFeedback"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt FeedbackLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from decimal import Decimal
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.event_handler import APIGatewayRestResolver
          from aws_lambda_powertools.utilities.typing import LambdaContext
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent
          
          # Helper class to convert Decimal to float for JSON serialization
          class DecimalEncoder(json.JSONEncoder):
              def default(self, o):
                  if isinstance(o, Decimal):
                      return float(o)
                  return super(DecimalEncoder, self).default(o)

          # Initialize PowerTools
          logger = Logger(service="submit-feedback")
          tracer = Tracer(service="submit-feedback")
          metrics = Metrics(namespace="MyApp", service="submit-feedback")

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              # Create API Gateway event object for easier parsing
              event_obj = APIGatewayProxyEvent(event)
              function_name = context.function_name
              
              # Log structured information
              logger.info("Function invoked", extra={
                  "function_name": function_name,
                  "request_id": context.aws_request_id
              })
              
              # Add custom annotation for X-Ray
              tracer.put_annotation(key="function_name", value=function_name)
              
              # Add business metrics
              metrics.add_metric(name="FeedbackSubmission", unit="Count", value=1)
              
              # Example accessing env vars (uncomment if needed)
              # table_name = os.environ.get('TABLE_NAME')
              # tracer.put_metadata(key="table_name", value=table_name)

              # Your business logic would go here
              response_body = {
                  "message": f"Placeholder success from {function_name}",
              }
              
              return {
                  "statusCode": 200,
                  "headers": {
                      "Content-Type": "application/json"
                  },
                  "body": json.dumps(response_body, cls=DecimalEncoder)
              }
      Environment:
        Variables:
          TABLE_NAME: !Ref FeedbackTable
      Timeout: 15
      MemorySize: 128
      TracingConfig:
        Mode: Active



  GetAnalyticsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-GetAnalytics"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt AnalyticsLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from decimal import Decimal
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.event_handler import APIGatewayRestResolver
          from aws_lambda_powertools.utilities.typing import LambdaContext
          from aws_lambda_powertools.logging import correlation_paths
          from aws_lambda_powertools.utilities.data_classes import APIGatewayProxyEvent
          
          # Helper class to convert Decimal to float for JSON serialization
          class DecimalEncoder(json.JSONEncoder):
              def default(self, o):
                  if isinstance(o, Decimal):
                      return float(o)
                  return super(DecimalEncoder, self).default(o)

          # Initialize PowerTools
          logger = Logger(service="get-analytics")
          tracer = Tracer(service="get-analytics")
          metrics = Metrics(namespace="MyApp", service="get-analytics")

          @logger.inject_lambda_context(correlation_id_path=correlation_paths.API_GATEWAY_REST)
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              # Create API Gateway event object for easier parsing
              event_obj = APIGatewayProxyEvent(event)
              function_name = context.function_name
              
              # Log structured information
              logger.info("Function invoked", extra={
                  "function_name": function_name,
                  "request_id": context.aws_request_id
              })
              
              # Add custom annotation for X-Ray
              tracer.put_annotation(key="function_name", value=function_name)
              
              # Add business metrics
              metrics.add_metric(name="AnalyticsRequest", unit="Count", value=1)
              
              # Example accessing env vars (uncomment if needed)
              # orders_table = os.environ.get('ORDERS_TABLE')
              # tracer.put_metadata(key="orders_table", value=orders_table)

              # Your business logic would go here
              response_body = {
                  "message": f"Placeholder success from {function_name}",
              }
              
              return {
                  "statusCode": 200,
                  "headers": {
                      "Content-Type": "application/json"
                  },
                  "body": json.dumps(response_body, cls=DecimalEncoder)
              }
      Environment:
        Variables:
          ORDERS_TABLE:    !Ref OrdersTable
          CUSTOMERS_TABLE: !Ref CustomersTable
          RDS_ENDPOINT:    !GetAtt AnalyticsDBInstance.Endpoint.Address
          RDS_PORT:        !GetAtt AnalyticsDBInstance.Endpoint.Port
          RDS_DB_NAME:     !Sub "${ProjectName}AnalyticsDB"
          RDS_SECRET_ARN:  !Ref DBPasswordSecret
      Timeout: 60
      MemorySize: 256
      TracingConfig:
        Mode: Active



  PaymentStepLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-PaymentStepPlaceholder"
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt PaymentStepLambdaRole.Arn
      Layers:
        - !Ref PowertoolsLayerArn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from decimal import Decimal
          from aws_lambda_powertools import Logger, Tracer, Metrics
          from aws_lambda_powertools.utilities.typing import LambdaContext
          
          # Helper class to convert Decimal to float for JSON serialization
          class DecimalEncoder(json.JSONEncoder):
              def default(self, o):
                  if isinstance(o, Decimal):
                      return float(o)
                  return super(DecimalEncoder, self).default(o)

          # Initialize PowerTools
          logger = Logger(service="payment-step")
          tracer = Tracer(service="payment-step")
          metrics = Metrics(namespace="MyApp", service="payment-step")

          @logger.inject_lambda_context
          @tracer.capture_lambda_handler
          @metrics.log_metrics(capture_cold_start_metric=True)
          def lambda_handler(event, context: LambdaContext):
              function_name = context.function_name
              
              # Log structured information
              logger.info("Function invoked", extra={
                  "function_name": function_name,
                  "request_id": context.aws_request_id
              })
              
              # Add custom annotation for X-Ray
              tracer.put_annotation(key="function_name", value=function_name)
              tracer.put_annotation(key="step_function_execution", value="true")
              
              # Add business metrics
              metrics.add_metric(name="PaymentStepExecution", unit="Count", value=1)
              
              # Create a subsegment for additional tracing detail
              # Your business logic would go here
              # Note: Step Functions expect a different response format than API Gateway
              response = {
                  "message": f"Placeholder success from {function_name}",
                  "received_event": event
              }
              
              # Convert any Decimal values to float for JSON serialization
              return json.loads(json.dumps(response, cls=DecimalEncoder))
      Environment:
        Variables:
          EXAMPLE_VAR: "PaymentStepValue"
      Timeout: 30
      MemorySize: 128
      TracingConfig:
        Mode: Active


  ### Step Functions ###
  PaymentProcessingStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub "${ProjectName}-PaymentProcessor"
      RoleArn: !GetAtt StateMachineRole.Arn
      DefinitionString: !Sub |-
        {
          "Comment": "Placeholder Payment Processing Workflow based on Scale-up text",
          "StartAt": "ValidatePayment",
          "States": {
            "ValidatePayment": {
              "Type": "Task",
              "Resource": "${PaymentStepLambdaFunction.Arn}",
              "Next": "ProcessExternally"
            },
            "ProcessExternally": {
              "Type": "Task",
              "Resource": "${PaymentStepLambdaFunction.Arn}",
              "Retry": [{
                "ErrorEquals": ["States.TaskFailed"],
                "IntervalSeconds": 3,
                "MaxAttempts": 2,
                "BackoffRate": 1.5
              }],
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "Next": "PaymentFailedNotification"
              }],
              "Next": "UpdateOrderStatus"
            },
            "UpdateOrderStatus": {
              "Type": "Task",
              "Resource": "${PaymentStepLambdaFunction.Arn}",
              "End": true
            },
            "PaymentFailedNotification": {
              "Type": "Task",
              "Resource": "${PaymentStepLambdaFunction.Arn}",
              "End": true
            }
          }
        }
      TracingConfiguration:
        Enabled: true

  ### API Gateway ###
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${ProjectName}-Api"
      Description: "(SHOWCASE ONLY) Scaled API structure for Serverless App"
      EndpointConfiguration:
        Types: [REGIONAL]


  CognitoAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      Name: !Sub "${ProjectName}-CognitoAuthorizer"
      Type: COGNITO_USER_POOLS
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref RestApi
      ProviderARNs:
        - !GetAtt UserPool.Arn

  RootOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !GetAtt RestApi.RootResourceId
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  RegisterResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: register

  RegisterPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref RegisterResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RegisterUserFunction.Arn}/invocations

  RegisterOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref RegisterResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  LoginResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: login

  LoginPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref LoginResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LoginUserFunction.Arn}/invocations

  LoginOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref LoginResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  OrdersResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: orders

  OrdersPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref OrdersResource
      HttpMethod: POST
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateOrderFunction.Arn}/invocations

  OrdersGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref OrdersResource
      HttpMethod: GET
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetOrdersFunction.Arn}/invocations

  OrdersOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref OrdersResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  OrderByIdResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !Ref OrdersResource
      PathPart: "{orderId}"

  OrderByIdGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref OrderByIdResource
      HttpMethod: GET
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      RequestParameters:
        method.request.path.orderId: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetOrderDetailsFunction.Arn}/invocations

  OrderByIdOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref OrderByIdResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  FeedbackResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: feedback

  FeedbackPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref FeedbackResource
      HttpMethod: POST
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SubmitFeedbackFunction.Arn}/invocations

  FeedbackOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref FeedbackResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  AnalyticsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId
      PathPart: analytics

  AnalyticsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref AnalyticsResource
      HttpMethod: GET
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref CognitoAuthorizer
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetAnalyticsFunction.Arn}/invocations

  AnalyticsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref AnalyticsResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode":200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - RegisterPostMethod
      - LoginPostMethod
      - OrdersPostMethod
      - OrdersGetMethod
      - OrderByIdGetMethod
      - FeedbackPostMethod
      - AnalyticsGetMethod
    Properties:
      RestApiId: !Ref RestApi
      StageName: showcase              # creates “showcase”
      StageDescription:                # configures it
        TracingEnabled: true
        MethodSettings:
          - ResourcePath: '/*'
            HttpMethod: '*'
            LoggingLevel: INFO
            MetricsEnabled: true
            DataTraceEnabled: false
            ThrottlingBurstLimit: 100
            ThrottlingRateLimit: 50


  ### Lambda Permissions ###
  RegisterLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt RegisterUserFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/POST/register

  LoginLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LoginUserFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/POST/login

  CreateOrderLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt CreateOrderFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/POST/orders

  GetOrdersLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt GetOrdersFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/GET/orders

  GetOrderDetailsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt GetOrderDetailsFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/GET/orders/*

  SubmitFeedbackLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt SubmitFeedbackFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/POST/feedback

  GetAnalyticsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt GetAnalyticsFunction.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/GET/analytics

Outputs:
  ApiEndpoint:
    Description: Invoke URL for the API Gateway stage
    Value: !Sub "https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/showcase"
  CognitoUserPoolId:
    Description: ID of the Cognito User Pool
    Value: !Ref UserPool
  CognitoUserPoolClientId:
    Description: ID of the Cognito User Pool Client
    Value: !Ref UserPoolClient
  CustomersTableName:
    Description: Name of the DynamoDB table for Customers
    Value: !Ref CustomersTable
  OrdersTableName:
    Description: Name of the DynamoDB table for Orders
    Value: !Ref OrdersTable
  FeedbackTableName:
    Description: Name of the DynamoDB table for Feedback
    Value: !Ref FeedbackTable
  PaymentStateMachineArn:
    Description: ARN of the placeholder Payment Processing Step Functions State Machine
    Value: !Ref PaymentProcessingStateMachine
  RedisCacheEndpoint:
    Description: Endpoint address for the ElastiCache Redis cluster
    Value: !GetAtt RedisCacheCluster.RedisEndpoint.Address
  RedisCachePort:
    Description: Endpoint port for the ElastiCache Redis cluster
    Value: !GetAtt RedisCacheCluster.RedisEndpoint.Port
  AnalyticsDBEndpoint:
    Description: Endpoint address for the RDS PostgreSQL analytics database
    Value: !GetAtt AnalyticsDBInstance.Endpoint.Address
  AnalyticsDBPort:
    Description: Endpoint port for the RDS PostgreSQL analytics database
    Value: !GetAtt AnalyticsDBInstance.Endpoint.Port
  AnalyticsDBName:
    Description: Name of the RDS PostgreSQL analytics database
    Value: !Sub "${ProjectName}AnalyticsDB"
  DBPasswordSecretArn:
    Description: ARN of the Secrets Manager secret holding the RDS master password
    Value: !Ref DBPasswordSecret
  VpcId:
    Description: ID of the created VPC
    Value: !Ref VPC
  PublicSubnetIds:
    Description: IDs of the public subnets
    Value: !Join [",", [!Ref PublicSubnetA, !Ref PublicSubnetB]]
  LambdaSecurityGroupId:
    Description: ID of the Security Group used by Lambda functions
    Value: !Ref LambdaSecurityGroup
